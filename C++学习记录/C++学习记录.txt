1.内存分区模型
    ・代码区：存放函数体的二进制代码，由操作系统进行管理
        存放CPU执行的机器指令
        代码是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
        代码是只读的，防止程序意外地修改了它的指令
    ・全局区：存放全局变量和静态变量以及常量
        全局变量和静态变量存放在此
        全局区还包括常量区，字符串常量和其他常量也存放于此
        该区域的数据在程序结束后由操作系统释放
    总结：
        ・C++中在程序运行前分为全局区和代码区
        ・代码区特点是共享和只读
        ・全局区中存放全局变量、静态变量、常量
        ・常量区中存放const修饰的全局常量和字符串常量
    ・栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
        注意事项：不要返回局部变量的地址，栈区开辟的地址由编译器自动释放
    ・堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收
    总结：
        堆区数据由程序员管理开辟和释放
        在C++中主要利用'NEW'在堆区开辟内存
    内存四区意义：
    不同区域存放数据，赋予不同的生命周期，给我们更大的灵活编程

2.NEW操作符
    在C++中主要利用'NEW'在堆区开辟内存，利用操作符delete手动释放
    堆区数据由程序员管理开辟和释放
    语法： new 数据类型
    利用new创建的数据，会返回该数据对应类型的指针
    int*  func()
    {
        int* p = new int(10);  //new->在堆区开辟新的内存
        return p;              //利用new关键字，可以将数据开辟到堆区
        //指针本质也是局部变量，放在栈上，指针保存的数据是放在堆区
    }
    int main()
    {
        int* p = func();
        cout << *p << endl;
        cout << *p << endl;
        cout << *p << endl;
        cout << *p << endl;
        delete p;   //删除数组  delete [] arr;   
    }
3.引用
    使用场景：
        比指针简单
    int a=10;
    int &ref=a;
    注意事项：
        1.不要函数引用->不要引用局部变量
        2.引用需要初始化
        3.初始化后不能改变指向
    本质：
        指针常量
        编译器会自动得将 int &ref=a -> int *const ref=a;
        所以指针得指向是无法修改的，但指针指向的值可以修改
4.常量引用
    使用场景：用来修饰形参，防止误操作

    int &ref=10;  //×引用必须引一块合法内存空间
    const int &ref=10; //√ 
    编译器将代码自动修改成:
        int temp=10;
        const int &ref=temp;
5.函数提高
    5.1・函数的默认参数
        语法：返回值类型 函数名（数据类型 默认值）{}
        int func(int a,b=10,c=10)
            return a+b+c;
        注意事项：
            1.如果某个位置已经有了默认参数，那么这个位置往后都需要有默认参数
                int func(int a,b=10,c)  //×
            2.如果函数的声明有了默认参数，那么这个函数的实现就不能有默认的参数
            只能函数声明或函数定义一方中有默认参数
                #define<stdio.h>
                int func(int a=10,int b=10)
                    ・・・・・・・・
                int func(int a=20,int b=20)   //× 将会出现 ‘二义性’
                    return a+b;
    5.2・函数的占位参数
        语法：返回值类型 函数名（数据类型）{}
        int func(int a,int)
            return a;
            注意事项：
            1.占位参数可以有默认参数
1.函数重载
    1.1函数重载的概述
        作用：函数名可以相同，提高复用性

        函数重载满足条件：
            ・同一个作用域下
            ・函数名相同
            ・函数参数‘类型不同’或‘个数不同’或者‘顺序不同’

        注意：函数的‘返回值’不可以作为函数重载的条件

        #.........
        int func(int a,int b);
        int func(double a,double b);
        int func(int b,int a);
        void func(int a,int b);
        int main()
        {
            func(a,b)//√
            func(a,b)//√
            func(b,a)//√
            func(a,b)//×,无法根据返回值重载，产生二义性
        }
    1.2函数重载的注意事项
        1・引用作为函数重载
        #.........
        //参数值类型不同，编译通过
        void func(int &a);       
        void func(const int &a);
        int main()
        {
            int a=10;
            func(a);
            //将调用 void func(int *a),a是变量，而const int &a->只读
            func(10);
            //将调用 void func(const....)，const...自动转换
            {
                int temp=10;
                const int &a=temp;
            }    
            而void func(int &a=10)是不合法的
        }
        2・函数重载碰到默认参数
        #.........
        void func(int a);
        void func(int a,int b=10);
        int main()
        {
            //报错，出现二义性
            func(10);
        }
2.类和对象
    C++面向对象的三大特性：‘封装、继承、多态’
    C++认为‘万事万物都皆为对象’，对象上有其属性和行为

    例如：
        人可以作为对象，属性有姓名、年龄、身高...
        具有相同性质的对象，我们可以抽象称为类，人属于人类、车属于车类
    2.1封装
        2.1.1封装的意义
            封装的意义：
            ・将属性和行为作为一个整体，表现生活中的事物
            ・将属性和行为加以权限控制

            封装的意义一：
                在设计类的时候，属性和行为写在一起，表现事物
            语法：
                class 类名{访问权限：属性/行为}
                //类中的属性和行为统称为‘成员’
                //属性->成员属性 成员变量
                //行为->成员行为 成员方法
            #.......
            const double PI = 3.14;
            class Circle
            {
            public:               //访问权限
                int R;                //属性
                double calculateZC()//行为
                {
                    return 2 * PI * R;
                }
            };
            int main()
            {
                Circle c1; //通过圆类，创建具体的圆（对象）
                c1.R = 10;
                cout << "周长：" << c1.calculateZC() << endl;
            }

            封装意义二：
            类在设计时，可以把属性和行为放在不同的权限下，加以控制
            访问权限有三种：
                1.公共权限 public    //在类内外都可以被访问
                2.保护权限 protected //类内可以访问，类外不可以访问
                3.私有权限 private   //类内可以访问，类外不可以访问
        2.1.2class和struct的区别
            在C++中区别在于默认权限不同：struct->public,class->private

        2.1.3成员属性设置为私有
            优点：
                ・可以自己控制读写权限
                ・对于写可以检测数据的有效性
                class humen
                {
                //通过公共的行为操作属性能够很好的保护私有属性
                public: //可读可写
                    void setName(string name)
                    {
                        name = name;
                    }
                    string getName(string name)
                    {
                        return name;
                    }
                public: //只读
                    int getAge()
                    {
                        return age;
                    }
                
                public: //检测数据有效性
                    void setAge(int age)
                    {
                        if (age < 0 || age >100)
                        {
                            age = 0;
                            return;
                        }
                        age = age;
                    }
                public: //只写
                    void setLover(string lover)
                    {
                        lover = lover;
                    }
                private:
                    string name;
                
                    int age;
                
                    string lover;
                };
                
                int main()
                {
                    humen p;
                    p.setName("张三");
                }
        封装案例：
            //分别用成员函数和全局函数判断两立方体是否相同
            class Cube
            {
            public:
            int getM_H()
            {
                return m_H;
            }
            int getM_L()
            {
                return m_L;
            }
            int getM_W()
            {
                return m_W;
            }
            void setM_H(int H)
            {
                m_H = H;
            }
            void setM_L(int L)
            {
                m_L = L;
            }
            void setM_W(int w)
            {
                m_W =w;
            }

            int V()
            {
                return m_H * m_L * m_W;
            }
            bool isSamebyclass(Cube &c)
            {
                if (m_L == c.getM_L() && m_H == c.getM_H() && m_W == c.getM_W())
                    return true;
                else
                    return false;
            }
            private:
                int m_H;
                int m_L;
                int m_W;
            };
            bool isSamebyGolbal(Cube &c1,Cube &c2)
            {
                if(c1.getM_H==c2.getM_H && c1.getM_L==c2.getM_L && c1.getM_W==c2.getM_W)
                    return true;
                else 
                    return false;
            }
            int main()
            {
                Cube c1;
                c1.setM_H(10);
                c1.setM_L(10);
                c1.setM_W(10);

                Cube c2;
                c2.setM_H(10);
                c2.setM_L(10);
                c2.setM_W(10);
                bool ret1=c1.isSamebyclass(Cube c2);
                bool ret2=isSamebyGolbal(Cube c1,Cube c2);
            }
    2.2对象的初始化和清理
        2.2.1构造函数和析构函数
            对象的‘初始化和清理’是两个非常重要的安全问题
                一个对象或者变量没有初始状态，对其使用后果是未知的
                同样的使用完一个对象或变量，没有及时清理，也会造成一定安全问题
            C++利用构造函数和析构函数解决上述问题，这两个函数会被编译器自动调用，完成对象初始化和清理工作
            对象初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译会自动的提供
            但提供的构造函数和析构函数是‘空实现’（没有任何代码）
            
                ・构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用
                ・析构函数：主要作用于对象销毁前系统自动调用，执行一些清理工作
            
            构造函数语法：类名(){}
            1.构造函数，没有返回值也不写void 
            2.函数名称与类名相同
            3.构造函数可以有参数，因此可以发生重载
            4.程序在调用对象时候自动调用构造，无须手动调用

            析构函数语法：~类名(){}
            1.析构函数，没有返回值也不写void
            2.函数名称与类名相同，在名称前加上符号~
            3.析构函数‘不可以有参数’，因此不可以发生重载
            4.程序在对象销毁前会自动调用析构，无须手动调用
            class Person
            {
            public:
            
                Person()
                {
                    cout << "构造函数的调用" << endl;
                }
            
                ~Person()
                {
                    cout << "析构函数的调用" << endl;
                }
            };
            void test() //存在栈中，调用完后自动释放，构造和析构一次产生
            {
                
                Person p;
            }
            
            int main()
            {
                test();
                Person p; //局部变量，构造函数调用，当程序关闭，析构函数调用
                system("pause");
                return 0;
            }
            CMD中执行结果：
                构造函数的调用
                析构函数的调用
                构造函数的调用
                请按任意键继续. . .
                析构函数的调用
        2.2.2构造函数的分类及调用
            两种分类方式：
                把参数分为：由参构造和无参（默认）构造
            三种调用方式：
                1.括号法
                2.显示法
                3.隐式转换法
            注意事项：
                ・在调用默认构造函数时候，不要加()，会被编译器认为是函数声明将不会创建对象
                ・不要利用拷贝函数构造函数来初始化匿名对象
                class Person
                {
                public:
                    //按照有无参数调用构造函数
                    Person()
                    {
                        cout << "无参构造函数的调用" << endl;
                    }
                    Person(int a)
                    {
                        age = a;
                        cout << "有参构造函数的调用" << endl;
                    }
                    //拷贝构造函数
                    Person(const Person &p)
                    {
                        //将传入的人身上的所有属性，拷贝到本人身上
                        age = p.age;
                    }
                
                    int age;
                };
                //调用
                void test01()
                {
                    //1.括号法调用
                    Person p1;     //默认（无参）参数
                    Person p2(10); //有参
                    Person p3(p2); //拷贝构造函数
                    //Person p1();    将会被认为函数声明，不会创建对象
                
                    //2.显示法调用
                    Person p1;
                    Person p2 = Person(10);//有参
                    Person p3 = Person(p2);//拷贝
                
                    Person(10); //匿名对象 特点：当前行执行结束后，系统会立即回收匿名对象
                    //Person(p3);//编译器会认为Person (p3) === Person p3; 对象声明，会被认为重定义，利用拷贝×
                    
                    //3.隐式转换法
                    Person p4 = 10;//相当于写了Person p4= Person (10)
                    Person p5 = p4;//相当于写了Person p5= Person (p4)
                }
                int main()
                {
                    test01();
                }
        2.2.3拷贝构造函数调用时机
            C++中拷贝构造函数调用时机通常有三种情况
            ・使用一个‘已经创建完毕’的对象来‘初始化一个新对象’
            ・‘值传递’的方式给函数参数传值
            ・以‘值方式’返回局部对象
        2.2.4构造函数调用规则
            默认情况,C++编译器至少给一个类添加3个函数
            1.默认构造函数（无参，函数体为空）
            2.默认析构函数（无参，函数体为空）
            2.默认拷贝构造函数，对属性进行值拷贝
            
            ・如果用户定义有参构造函数，C++：
                1.不提供 2.提供 3.提供
            ・如果用户定义拷贝构造函数，C++：
                1.不提供 2.不提供 3.不提供
        2.2.5深拷贝和浅拷贝
            浅拷贝：简单的赋值拷贝操作
            深拷贝：堆区重新申请空间，进行拷贝操作
            浅拷贝带来的问题是‘堆区重复释放’
            利用深拷贝再堆区重新再开辟新的内存解决重复释放
            导致的非法操作问题
            class Person
            {
            public:
                Person()
                {
                    cout << "默认构造函数调用" << endl;
                }
                Person(int age,int m_height)
                {
                    m_Age = age;
                    m_Height = new int(m_height);
                    cout << "有参构造函数调用" << endl;
                }
                //编译器提供的拷贝函数‘只会做浅拷贝’
                Person(const Person &p)
                {
                    cout << "拷贝构造函数调用" << endl;
                    m_Age = p.m_Age;
                    m_Height = new int(*p.m_Height);
                }
                ~Person()
                {
                    //释放堆区内容
                    if (m_Height != NULL)
                    {
                        delete m_Height;
                        m_Height = NULL;
                    }
                    cout << "析构函数调用" << endl;
                }
                int m_Age;
                int *m_Height;
            };
        2.2.6初始化列表
            作用：提供初始化列表语法，用来初始化属性
            语法：构造函数():属性1(),属性2(),属性3()...{}
            class Person
            {
            public:
            //隐式转换法
                Person(int a,int b,int c):m_a(a),m_b(b),m_c(c){}
            int m_a;
            int m_b;
            int m_c;
            }
        2.2.7类对象作为类成员
            C++类中的成员可以是另一个类的对象
            class A{};
            class B
            {
                A a;
            };
        2.2.8静态成员
            静态成员就是在成员变量和成员函数前加上关键字Static
            静态成员分为：
                ・静态成员变量
                    1.所有对象共享同一份数据
                    2.在编译阶段分配内存   //在编译内存时分配（程序未运行）
                    3.类内声明，类外初始化
                class Person
                {
                public:
                    static int a;   //类内声明
                };
                注意事项：
                    静态成员变量不属于某个对象，所有对象共享同一份数据
                    静态成员变量有访问权限
                访问静态成员变量有两种方式：
                    1.通过对象 2.通过类名
                        1.Person p;
                            p.a; 
                        2.Person::a;
                int Person::a=100;  //类外初始化
                ・静态成员函数
                    1.所有对象共享同一个函数
                    2.静态成员函数‘只能访问’‘静态成员变量’
                class Person
                {
                public:
                    static void func(int a);   //类内声明
                }; 
                注意事项:
                    1.静态成员函数不属于某个对象，所有对象共享同一份函数
                    2.静态成员函数有访问权限 
                访问静态成员变量有两种方式：
                1.通过对象 2.通过类名
                    1.Person p;
                        p.func(); 
                    2.Person::func();
    2.3C++对象模型和this指针
        2.3.1成员变量和成员函数分开存储
            在C++中，类内的成员变量和成员函数分别存储
            只有非静态成员变量才属于类的对象上
            C++编译器会给每个空对象分配1个内存，为了区分空对象占内存的位置
            每个空对象都有独一无二的内存地址
            只有非静态成员变量属于类的对象，除此之外静态成员、非静态函数和静态函数都不属于
        2.3.2this指针概念
            this指针指向被调用的成员函数所属的对象
            this指针是隐含在每一个非静态成员函数内的一种指针
            this指针不需要定义，直接使用即可

            class Person
            {
            public:
                //解决名称冲突
                Person(int age)
                {
                    //this 指向被调用成员函数所属的对象
                    this->age = age;
                }
                //要返回本体必须加上引用符号&
                Person& PersonAddAge(Person& p)
                {
                    this->age += p.age;
                    return *this;
                }
                int age;
            };
            void test1()
            {
                Person p1(18);
                cout << "p1的年龄为：" << p1.age << endl;
            }
            void test2()
            {
                Person p1(10);
                Person p2(10);
                //链式编程思想
                p2.PersonAddAge(p1).PersonAddAge(p1);
                cout << "p2的年龄为：" << p2.age << endl;
            }
        2.3.3空指针访问成员函数
            C++中空指针也是可以调用成员函数，但是也要注意有没有用到this指针
            如果用到this指针，需要判断程序的健壮性
            class Person
            {
                void showPersonAge()
                {
                    //为了确保程序健壮性，需要改进成以下代码
                    if(this==NULL)
                        return ;
                    cout<<"age= "<<m_Age<<endl;   m_Age (this->m_Age)
                }
                int m_Age;
            }
            void test1()
            {
                Person *p1=NULL;
                p1->showPersonAge() //程序将出错,加入if条件语句后正常
            }
        2.3.4const修饰成员函数
            常函数：
                ・成员函数后加const后我们称为这个函数为常函数
                ・常函数内不可以修改成员属性
                ・成员属性声明时加关键字mutable后，在常函数中依然可以修改
            常对象：
                ・声明对象前加const称该对象为常对象
                ・常对象只能调用常函数
                class Person
                {
                public:
                    /*
                        this指针的本质是指针常量，所以指针的指向是无法修改的
                        Person * const this
                    */
                    //变成常函数后实质为->cosnt Person* const this 
                    void showPerson() const
                    {
                        //m_A = 100;   //this->m_A=100 ; 常函数中是无法操作的
                        m_B = 100;
                    }
                    void showPerson1()
                    {
                        m_A = 100;
                    }
                    int m_A;
                    mutable int m_B;
                };
                void test1()
                {
                    const Person p1;
                    //p1.m_A = 100;
                    p1.m_B = 100;
                    //p1.showPerson1();  //常对象只能调用常函数
                }
    2.4友元
        在程序里，有些私有属性，也想让类外特殊的一些函数或者类来特殊访问，就需要用到友元
        友元的目的就是让一个函数或者类，访问另一个类中私有成员
        关键字：‘friend’

        友元的三种三种实现
            ・全局函数做友元
            ・类做友元
            ・成员函数做友元
            class Building; //提前声明有Building 这么一个类
            class GoodFriend
            {
            public:
                GoodFriend();
                void visit();
            private:
                Building* building;
            };
            class GoodFriend_1
            {
            public:
                GoodFriend_1();
                void visit1();
                void visit2();
            private:
                Building* building1;
            };
            
            class Building
            {
                //全局函数做友元
                friend void friend_visit(Building* building);
                //类做友元
                friend class GoodFriend;
                //类成员函数做友元
                friend void GoodFriend_1::visit1();
            public:
                Building();
            public:
                string m_sittingRoom;
            private:
                string m_BedRoom;
            };
            void friend_visit(Building* building)
            {
                cout << "朋友正在访问：" << building->m_sittingRoom << endl;
                cout << "朋友正在访问：" << building->m_BedRoom<< endl;
            }
            Building::Building()
            {
                this->m_sittingRoom = "客厅";
                this->m_BedRoom = "卧室";
            }
            GoodFriend::GoodFriend()
            {
                building = new Building;
            }
            GoodFriend_1::GoodFriend_1()
            {
                building1 = new Building;
            }
            void GoodFriend::visit()
            {
                cout << "好朋友正在访问：" << building->m_BedRoom << endl;
                cout << "好朋友正在访问：" << building->m_sittingRoom << endl;
            }
            void  GoodFriend_1::visit1()
            {
                cout << "朋友正在访问：" << building1->m_sittingRoom << endl;
                cout << "朋友正在访问：" << building1->m_BedRoom << endl;
            }
            void GoodFriend_1::visit2()
            {
                //GooFriend_1的类函数visit2()无权不是Building的友元，无权访问卧室
                cout << "朋友正在访问：" << building1->m_sittingRoom << endl;
                //cout << "朋友正在访问：" << building1->m_BedRoom << endl;
            }
            void test1()
            {
                GoodFriend frank;
                frank.visit();
                Building p1;
                friend_visit(&p1);
                GoodFriend_1 Tom;
                Tom.visit1();
            }
    2.5运算符重载
        概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型
        2.5.1加号运算符重载
            class Operator
            {
            public:
                //1.成员函数重载运算符
                /*
                        Operator operator+(Operator p)
                {
                    Operator temp;
                    temp.m_a = this->m_a + p.m_a;
                    temp.m_b = this->m_b + p.m_b;
                    return temp;
                }
                */
            
            public:
                int m_a;
                int m_b;
            };
            //2.全局函数重载运算符
            Operator operator+(Operator& p,Operator& p1)
            {
                Operator temp;
                temp.m_a = p.m_a + p1.m_a;
                temp.m_b = p.m_b + p1.m_b;
                return temp;
            }
            void test1()
            {
                Operator p1, p2;
                p1.m_a = 10;
                p2.m_a = 10;
                p1.m_b = 20;
                p2.m_b = 20;
                //1.成员函数重载运算符的本质：Operator p3 = p1.operator+(p2);
                //2.全局函数重载运算符的本质：Operator p3 = operator+(p1,p2);
                //3.运算符也可以发生函数重载
                Operator p3 = p1 + p2;
                cout << "p3.m_a=" << p3.m_a << endl;
                cout << "p3.m_b=" << p3.m_b << endl;
            }
            总结1：对于内置的数据类型的表达式的运算符无法更改
            总结2：不要滥用运算符重载->加变乘
        2.5.2左移运算符重载
            class Person
            {
                friend ostream& operator<< (ostream & cout, Person p1);
            public:
                
            private:
                int m_a=10;
                int m_b=10;
            };
            //1.全局函数重载左移运算符
            ostream& operator<<(ostream&cout,Person p1)
            {
                //链式编程
                cout << p1.m_a ;
                return cout;
            }
            注意事项：
                ostream对象只能有一个
        2.5.3递增&递减运算符重载
            class MyIniteger
            {
                friend ostream& operator<<(ostream& cout, MyIniteger p);
            public:
                //1.重载前置++运算符，返回引用是为了一直对一个数据操作
                MyIniteger& operator++()
                {
                    ++m_a;
                    return *this;
                }
                //1.1重载前置运算符--
                MyIniteger& operator--()
                {
                    --m_a;
                    return *this;
                }
                //2.重载后置++运算符，int 代表占位参数，可以区分前置和后置,返回值
                MyIniteger operator++(int)
                {
                    MyIniteger temp = *this;
                    m_a++;
                    return temp;    //局部变量，施加引用会导致非法访问
                }
                //2.2重载后置运算符--
                MyIniteger operator--(int)
                {
                    MyIniteger temp = *this;
                    m_a--;
                    return temp;
                }
                private:
                    int m_a=10;
                };
                ostream& operator<<(ostream& cout, MyIniteger p)
                {
                    cout << p.m_a;
                    return cout;
                }
                void test1()
                {
                    MyIniteger p1;
                    //cout << "++m_a : " << ++p1 << endl;
                    //cout << "m_a++ : " << p1++ << endl;
                    //cout << "--m_a : " << --p1 << endl;
                    cout << "m_a-- : " << p1-- << endl;
                    cout << p1 << endl;
                }
        2.5.4赋值运算符重载
            C++编译器至少给一个类添加4个函数
            1.默认构造
            2.默认构造（有参）
            3.拷贝函数
            4.赋值运算符operator=，对属性进行值拷贝
            如果类中有属性指向堆区，那么会涉及深浅拷贝的问题
            class Person
            {
            public:
                Person(int age)
                {
                    m_Age = new int(age);
                }
                Person& operator=(Person& p)
                {
                    //先判断是否有属性在堆区，如果有则先释放
                    if (m_Age != NULL)
                    {
                        delete m_Age;
                        m_Age = NULL;	
                    }
                    m_Age = new int(*p.m_Age);
                    return *this;
                }
                ~Person()
                {
                    if (m_Age != NULL)
                    {
                        delete m_Age;
                        m_Age = NULL;
                    }
                }
                int* m_Age;
            };
            void test1()
            {
                Person p1(18);
                Person p2(20);
                //Person p3 = p2 = p1;//p3的年龄内存和p2的一样
                Person p3(20);
                p3 = p1 = p2;
                cout << "p3 的年龄：" << *p3.m_Age << endl;
            }
        2.5.5关系运算符重载
            让两个自定义类型对象进行对比操作
            bool operator==(Person& p)
            {
                if(...)
                    return true/false;
                return false/true;
            }
        2.5.6函数调用运算符重载
            重载后使用的方式非常像函数调用，所以被称为仿函数
            返回类型 operator()(数据类型 形参，...)
            class ....
            {
            public:
                void operator()(int a)
                {
                    cout<<a<<endl;
                }
            };
            void test()
            {
                ... Myprint;
                Myprint(int a);
                ...()(int a);   //匿名函数对象，用完及释放
            }
    2.6继承
        2.6.1继承的基本语法
            拥有父类共性，也拥有自身的特性
            语法：class 子类 :继承方式 父类
            子类也称为派生类，父类也称为基类
            class BassPage
            {
            public:
                ....
            };
            //
            class Java:public BassPage
            {
            public:
            }
        2.6.2继承方式
            ・公共继承
            ・保护继承
            ・私有继承
        2.6.3继承中的对象模型
            父类中所有非静态成员属性都会被子类继承
            父类中私有成员属性是被编译器隐藏，因此访问不到
            打开vs的开发人员命令提示工具
            F：//跳转盘符
            cd 具体路径 //切换路径
            cl /d1 reportSingleClassLayout类名 文件名(Tab补全) //报告单个类模型
        2.6.4继承中构造和析构顺序
            先构造父类再构造子类，先析构子类再析构父类
        2.6.5继承中同名成员处理方式
            ・访问子类同名成员 直接访问即可
            ・访问父类同名成员 需要添加作用域
            class Bass
            {
            public:
                Bass()
                {
                    m_a=10;
                }
                void func()
                {
                    cout<<"父类调用"<<endl;
                }
                int m_a;
            };
            class Son : public Bass
            {
            public:
                Son()
                {
                    m_a=10;
                }
                void func()
                {
                    cout<<"子类调用"<<endl;
                }
                int m_a;
            };
            void test1()
            {
                Person p1;
                cout <<p1.m_a<<endl;
                cout <<p1.Bass::m_a<<endl;
                p1.func();
                p1.Bass::func();
            }
        2.6.6继承同名静态成员处理方式
            ・访问子类同名静态成员 直接访问即可
            ・访问父类同名静态成员 需要添加作用域
            同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式
            通过类名和对象
        2.6.7多继承语法
            C++允许一个类继承多个类
            语法：class 子类 : 继承方式 父类1,继承方式 父类2...
            当父类中出现同名成员，子类使用时需要加作用域区分
        2.6.8菱形继承
            两个派生类继承同一个基类，又有某个类同时继承这两个派生类
            这种继承被称为菱形继承或钻石继承
            菱形继承的问题：
                       动物
                     羊    驼
                       羊驼
            1.二义性->同名问题 2.重复数据的继承->羊驼会继承两份动物的数据，资源浪费
            解决方法：
            1.利用作用域 2.利用虚继承，继承之前加上关键字virtual,sheep : virtual public animal{};
    2.7多态
        2.7.1多态的基本概念
            多态分为两类  （多种形态）
                ・静态多态：函数重载和运算符重载
                ・动态多态：派生类和虚函数实现运行时多态
            静态多态和动态多态区别：
                ・静态多态的函数地址‘早绑定’
                ・动态多态的函数地址‘晚绑定’
            动态多态满足条件
                1.有继承关系
                2.子类重写父类的‘虚函数’
            动态多态使用
                ‘父类的指针或者引用 执行子类对象’
            class Animal
            {
            public:
                //虚函数
                virtual void speak()
                {
                    cout << "动物在说话" << endl;
                }
            };
            class Cat:public Animal
            {
            public:
                //重写 函数返回值类型 函数名 参数列表需要完全相同
                void speak()
                {
                    cout << "小猫在说话" << endl;
                }
            };
            class Dog :public Animal
            {
            public:
                void speak()
                {
                    cout << "小狗在说话" << endl;
                }
            };
            //地址早绑定，在编译阶段确定函数地址
            //如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要用到动态多态,地址晚绑定
            //即在动物类出加上virtual
            //动态多态的使用：父类的指针或者引用 执行子类对象
            void doSpeak(Animal& animal)//Animal &animal=cat
            {
                animal.speak();
            }
            void test1()
            {
                Cat cat;
                doSpeak(cat);	

                Dog dog;
                doSpeak(dog);
            }
            2.7.1.1多态的深入剖析
                看图例
        2.7.2多态案例一.计算器类
            多态的优点：
                ・代码组织结构清晰
                ・可读性强
                ・利于前期和后期的扩展以及维护
            ‘开闭原则：对扩展进行开发，对修改进行关闭’
            class AbastractCaculator
            {
            public:
                //虚函数
                virtual int getResult()
                {
                    return 0;
                }
                int m_Num1;
                int m_Num2;
            };
            class AddCaculator :public AbastractCaculator
            {
            public:
                virtual int getResult()
                {
                    return m_Num1 + m_Num2;
                }
            };
            class SubstrationCaculator :public AbastractCaculator
            {
            public:
                virtual int getResult()
                {
                    return m_Num1 - m_Num2;
                }
            };
            class MulCaculator :public AbastractCaculator
            {
            public:
                virtual int getResult()
                {
                    return( m_Num1 * m_Num2);
                }
            };
            void test1()
            {
                //创建一个加法计算器
                AbastractCaculator* abc = new AddCaculator;
                abc->m_Num1 = 10;
                abc->m_Num2 = 10;
                cout << abc->getResult() << endl;
                //用完记得销毁
                delete abc;
                abc = new SubstrationCaculator;
                cout << abc->getResult() << endl;
                delete abc;
                abc = new MulCaculator;
                abc->m_Num1 = 100;
                abc->m_Num2 = 100;
                cout << abc->getResult() << endl;
                delete abc;
            }
        2.7.3纯虚函数和抽象类
            在多态中，通常父类中虚函数的实现时毫无意义的，主要都是调用‘子类重写的内容’
            因此可以将虚函数改为纯虚函数
            语法：virtual 返回值类型 函数名（参数列表） = 0；
                virtual void func()=0;
            当类中有了纯虚函数，这个类也称为抽象类
            抽象类特点：  
                ・‘无法’实例化对象->栈上不可以，堆区也不可以创建内存
                ・子类‘必须重写’抽象类中的纯虚函数，不然也是抽象类
        2.7.4多态案例二.制作饮品
            class AbastractDrinking
            {
            public:
                virtual void Boil() = 0;
                virtual void Brew() = 0;
                virtual void PourInCup() = 0;
                virtual void AddInotherthing() = 0;
                void MakeDrink()
                {
                    Boil();
                    Brew();
                    PourInCup();
                    AddInotherthing();
                }
            };
            class MakeCoffee:public AbastractDrinking
            {
            public:
                virtual void Boil()
                {
                    cout << "煮水 农夫山泉" << endl;
                }
                virtual void Brew() 
                {
                    cout << "冲泡咖啡" << endl;
                }
                virtual void PourInCup() 
                {
                    cout << "倒入咖啡" << endl;
                }
                virtual void AddInotherthing()
                {
                    cout << "加入牛奶" << endl;
                }
            };
            //工作函数
            void doWork(AbastractDrinking* abs)
            {
                abs->MakeDrink();
            }
            void test()
            {
                doWork(new  MakeCoffee);
            }
        2.7.5虚析构和纯虚析构
            多态使用时，如果子类中有属性开辟到堆区，那么父类指针在‘释放时’无法调用到子类的析构代码
            解决方法：将父类中的析构函数改为‘虚析构’或者纯虚析构

            虚析构和纯虚析构共性：
                ・可以解决父类指针释放子类对象
                ・都需要有具体的函数实现
            虚析构和纯虚析构区别：
                ・如果是纯虚析构，该类属于抽象类，无法实例化对象
            虚析构语法：
                virtual ~类名(){}
            纯虚析构语法：
                virtual ~类名()=0;
                类名::~类名(){}    （类外必须要写的实现）
            总结：
                1.虚析构或纯虚析构就是用来解决父类指针释放子类对象
                2.如果子类中没有堆区数据，可以不写虚析构或纯虚析构
                3.拥有纯虚析构的类也属于抽象类
        2.7.6多态案例三.电脑组装
            class Abstraction_Cpu
            {
            public:
                virtual void  Cpu()  = 0;
            };
            class Abstraction_Gpu
            {
            public:
                virtual void   Gpu() = 0;
            };
            class Abstraction_Memory
            {
            public:
                virtual void   Memory() = 0;
            };
            class lenovo_Cpu :virtual public Abstraction_Cpu
            {
            public:
                virtual void  Cpu()
                {
                    cout << "lenovo_Cpu is working" << endl;
                }
            };
            class lenovo_Gpu :public Abstraction_Gpu
            {
            public:
                virtual void  Gpu()
                {
                    cout << "lenovo_Gpu is working" << endl;
                }
            };
            class  lenovo_Memory :public Abstraction_Memory
            {
            public:
                virtual void  Memory()
                {
                    cout << "lenovo_Memory is working" << endl;
                }
            };
            class Intel_Cpu :public Abstraction_Cpu
            {
            public:
                virtual void  Cpu()
                {
                    cout << "Intel_Cpu is working" << endl;
                }
            };
            class Intel_Gpu :public Abstraction_Gpu
            {
            public:
                virtual void  Gpu()
                {
                    cout << "Intel_Gpu is working" << endl;
                }
            };
            class Intel_Memory :public Abstraction_Memory
            {
            public:
                virtual void  Memory()
                {
                    cout << "Intel_Memory is working" << endl;
                }
            };
            class Abstraction_Computer 
            {
            public:
                /*
                void m_Computer(Abstraction_Cpu* m_Cpu, Abstraction_Gpu* m_Gpu, Abstraction_Memory* m_Memory)
                {
                    CPU= m_Cpu;
                    GPU = m_Gpu;
                    MEM = m_Memory;
                }
                */
                //有参构造
                Abstraction_Computer(Abstraction_Cpu* m_Cpu, Abstraction_Gpu* m_Gpu, Abstraction_Memory* m_Memory)
                {
                    CPU = m_Cpu;
                    GPU = m_Gpu;
                    MEM = m_Memory;
                }
                void doWork()
                {
                    CPU->Cpu();
                    GPU->Gpu();
                    MEM->Memory();
                }
                ~Abstraction_Computer()
                {
                    if (CPU != NULL)
                    {
                        delete CPU;
                        CPU = NULL;
                    }
                    if (GPU != NULL)
                    {
                        delete GPU;
                        GPU = NULL;
                    }
                    if (MEM != NULL)
                    {
                        delete MEM;
                        MEM = NULL;
                    }
                }
            private:
                Abstraction_Cpu* CPU;
                Abstraction_Gpu* GPU;
                Abstraction_Memory* MEM;
            };
            void test()
            {
                Abstraction_Cpu* IntelCpu = new Intel_Cpu;
                Abstraction_Gpu* IntelGpu = new Intel_Gpu;
                Abstraction_Memory* IntelMemory = new Intel_Memory;
                Abstraction_Computer* com1 = new Abstraction_Computer(IntelCpu, IntelGpu, IntelMemory);
                com1->doWork();
                delete com1;
            }
3.文件的操作
    程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放
    通过文件可以将数据持久化
    C++中对文件操作需要包含头文件<fstream>（文件流）
    文件类型分为两种
        1.文本文件 - 文件以文本的ASCII码形式存在计算机
        2.二进制文件 - 文件以文本的二进制形式存储在计算机中
    操作文件的三大类：
        1.ofstream：写操作
        2.ifstream：读操作
        3.fstream ：读写操作
    3.1文本文件
        3.1.1写文件步骤：
            1.#include<fstream>  
            2.ofstream ofs                   （创建流对象）
            3.ofs.open("文件路径"，打开方式)   （打开文件）
            4.ofs<<"写入的数据";              （写数据）
            5.ofs.close();                   （关闭文件）
            文件打开方式：
                打开方式        解释
                ios::in         为读文件打开文件
                ios::out        为写文件而打开文件
                ios::ate       初始位置：文件尾
                ios::app       追加方式写文件
                ios::trunc     如果文件存在先删除，再创建
                ios::binary    二进制方式
            注意：文件打开方式可以配合使用，利用|操作符
            总结：
                ・文件操作必须包含头文件fstream
                ・读文件可以利用ofstream
                ・打开文件时候需要指定操作文件的路径，以及打开方式
                ・利用<<可以向文件中写数据
                ・操作完毕，要关闭文件
            #include<fstream>
            void test()
            {
                ofstream ofs;
                ofs.open("text.txt", ios::out);
                ofs << "20.8.6" << endl;
                ofs.close();
            }
        3.1.2读文件
            1.#include<fstream>
            2.ifstream ifs;           //创建流对象
            3.ifs.open("文件路径"，打开方式)
            4.四种方式读取
                ・ifs>>buf
                ・ifs.getline(buf,sizeof(buf))
                ・getline(ifs,buf)
                ・ifs.get()
            5.ifs.close();
            char buf[1024] = { 0 };
            while (ifs>>buf)
            {
                cout << buf << endl;
            }
            while (ifs.getline(buf, sizeof(buf)))
            {
                cout << buf << endl;
            }
            ifs.close();
    3.2二进制文件
        以二进制的方式对文件进行读写
        打开方式要指定为'ios::binary'
        5.2.1读/写文件
            二进制方式写文件主要利用对象调用成员函数write
            函数原型:ostream& write(const char* buffer,int len)
            二进制方式读文件主要利用对象调用成员函数reade
            函数原型:ostream& read(const char* buffer,int len)
            #include<fstream>
            class Person
            {
            public:
                char m_Name[64];
                int m_Age;
            };
            void test()
            {
                //读操作
                ofstream ofs("Person.txt", ios::out | ios::binary);
                Person p = { "张三",18 };
                ofs.write((const char*)&p, sizeof(Person));
                ofs.close();
                //写操作
                ifstream ifs("Person.txt", ios::in | ios::binary);
                if (!ifs.is_open())
                {
                    cout<<"写失败"<<endl;
                    return;
                }
                ifs.read((char*)&p, sizeof(Person));
                cout << p.m_Name << ' ' << p.m_Age << endl;
                ifs.close();
            }
职工管理系统
    职工分类：员工、经理、老板
    信息：职工编号、职工姓名、职工岗位以及职责
    ・退出管理程序：退出职工管理系统
    ・增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号
    ・显示职工信息：显示公司内部所有职工的信息
    ・删除离职职工：按照编号删除指定员工
    ・修改职工信息：按照编号修改职工个人信息
    ・查找职工信息：按照职工编号或者职工的姓名进行查找相关人员信息
    ・按照编号排序：按照职工编号，进行排序，排序规则由用户指定
    ・清空所有文档：清空文件中记录的所有信息（删除前需要进行提醒防止误操作）
    
    ・文件已上传至GITHUB√
C++提高编程
    1.模板
        1.1模板概念
            ・主要针对C++泛型编程和STL技术做详细详解，探讨C++更深层次
            ・C++提供两种模板机制：函数模板和类模板
        1.2函数模板
            1.2.1函数模板语法
                语法：
                1.template<typename T>
                2.函数声明或定义
                template<typename T>   //T为通用数据类型
                void mySwap(T &a,T &b)
                {
                    T temp=a;
                    a=b;
                    b=temp;
                }

                void test()
                {
                    int a=10;
                    int b=20;
                    //两种方式使用函数模板
                    //1.自动类型推导
                    mySwap(a,b);
                    cout<<a<<b<<endl;
                    //2.显示自动类型
                    mySwap<int>(a,b);
                    cout<<a<<" "<<b<<endl;
                }
            1.2.2函数模板注意事项
                ・自动类型推导，必须推导出一致的‘数据类型T’才可以
                ・模板必须要确定出‘T的数据类型’，才可以使用
            1.2.3函数模板案例
                template<class T>
                void Swap(T &a,T &b)
                {
                    T temp=a;
                    a=b;
                    b=temp;
                }
                template<class T>
                void sort(T arr[],int len)
                {
                    int temp=0;
                    for(int i=0;i<len;i++)
                    {
                        int max=i;
                        for(int j=i;j<len;j++)
                        {
                            if(arr[max]<arr[j])
                            {
                                max=j;
                            }
                        }
                
                        if(max!=i)
                        {
                            Swap(arr[max],arr[i]);
                        }
                    }
                
                }
                template<class T> 
                void printArr(T arr[],int len)
                {
                    for(int i=0;i<len;i++)
                    {
                        cout<<arr[i]<<" ";
                    }
                }
                void test()
                {
                    char charArr[]={"baaksdjla"};
                    int len=sizeof(charArr)/sizeof(char);
                    sort(charArr,len);
                    printArr(charArr,len);
                
                    int intArr[]={6,3,2,68,86,1};
                    int len1=sizeof(intArr)/sizeof(int);
                    sort(intArr,len1);
                    printArr(intArr,len1);
                }
            1.2.4普通函数与函数模板的区别
                ・普通函数调用时‘可以发生’隐式类型转换
                ・函数模板调用
                    1.自动类型转换×    2.显示指定类型转换√
            1.2.5普通函数与函数模板的调用规则
                1.如果都可以实现，优先调用普通函数
                2.可以通过空模板参数列表来强制调用函数模板
                3.函数模板可以发生函数重载
                4.如果函数模板可以产生更好的匹配，优先调用
                总结：既然提供了函数模板，就不要提供普通函数，容易出现二义性
            1.2.6模板的局限性
                //具体化的模板，可以解决自定义类型的调用
                template<>Person myCompare(Person &p1,Person &p2)   
        1.3类模板
            1.3.1类模板语法
                template<class NameType,class AgeType>
                class Person
                {
                public:
                    Person(NameType name,AgeType age)
                    {
                        this->m_Name=name;
                        this->m_Age=age;
                    }
                    NameType m_Age;
                    AgeType m_Name;
                };
                void test()
                {
                    Person<string,int>p1("张三",25);
                }
            1.3.2类模板和函数模板的区别
                1.类模板没有自动类型推导的使用方式
                2.‘类模板’在模板参数列表中可以有默认参数
            1.3.3类模板中成员函数创建时机
                1.普通类中的成员函数一开始就可以创建
                2.类模板中的成员函数在调用时才创建
            1.3.4类模板对象作函数参数
                1.指定传入类型
                2.参数模板化
                3.整个类模板化
                template<class T1,class T2>
                class person
                {
                    public:
                    person(T1 name,T2 age)
                    {
                        this->m_age=age;
                        this->m_name=name;
                    }
                    void show()
                    {
                        cout<<this->m_name<<" "<<this->m_age<<endl;
                    }
                    T2 m_age;
                    T1 m_name;
                };
                //1.（常用）指定传入类型,类模板的对象作参数传入函数
                void printPerson1(person<string,int>&p)
                {
                    p.show();
                }
                //2.参数模板化
                template<class T1,class T2>
                void printPerson2(person<T1,T2>&p)
                {
                    p.show();
                    cout<<"T1的类型为："<<typeid(T1).name()<<endl;
                    cout<<"T2的类型为："<<typeid(T2).name()<<endl;
                }
                //3.整个类模板化
                template<class T>
                void printPerson3(T &p)
                {
                    p.show();
                    cout<<"T的类型为："<<typeid(T).name()<<endl;
                }
                void test()
                {
                    person<string,int>p1("ss2",100);
                    printPerson3(p1);
                }
            1.3.5类模板与继承         
                template<class T>
                class Base
                {
                    T m;
                };
                //class Son:public Base  ×，必须要指定数据类型，否则编译器无法分配指定内存
                class Son:public Base<int>{};
                //如果想灵活指定父类中T类型 ，子类也需要变类模板
                template<class T1,class T2>
                class Son2:public Base<T2>
                {
                    T1 obj;
                };
                void test1()
                {
                    Son2<int ,char>S2;   //int 指向子类T1  ，char 指向父类T
                }
            1.3.6类模板中成员函数的类外实现
                template<class T1,class T2>
                class Person
                {
                    Person(T1 age,T2 name);
                    void show();
                    T1 m_age;
                    T2 m_name;
                };
                //类模板构造函数类外实现
                template<class T1,class T2>
                Person<T1,T2>::Person(T1 age,T2 name)
                {
                        this->m_name=name;
                        this->m_age=age;
                }
                //类模板成员函数类外实现
                template<class T1,class T2>
                void Person<T1,T2>::show()
                {
                    cout<<"  "<<endl;
                }
            1.3.7类模板分文件编写
                1.直接主函数中直接添加源文件  #include"person.cpp"
                2.（常用）将头文件.h和源文件.cpp写在一起  #include"person.hpp"
            1.3.8类模板与友元
                ・类模板配合友元函数的类内类外实现
                //提前声明
                template<class T1,class T2>
                class person;

                template<class T1,class T2>
                void show2(person<T1,T2>p)
                {
                    cout<<p.m_name<<" "<<p.m_age<<endl;
                }
                //类模板对象作参数对象
                template<class T1,class T2>
                class person
                {
                    //1.全局函数 类内实现
                    friend void show(person<T1,T2>p)
                    {
                        cout<<p.m_name<<" "<<p.m_age<<endl;
                    }
                    //2.全局函数 类外实现
                    //加空模板参数列表
                    friend void show2<>(person<T1,T2>p);

                public:
                    person(T1 name,T2 age)
                    {
                        this->m_age=age;
                        this->m_name=name;
                    }
                private:
                    T2 m_age;
                    T1 m_name;
                };

                void test()
                {
                    person<string,int>p("Tom",20);
                    show(p);
                    show2<>(p);
                }
                总结：没有特殊需求，尽量用类内实现全局函数
            1.3.9类模板案例
                案例描述：实现一个‘通用’的‘数组类’，要求如下：
                ・可以对内置数据类型以及‘自定义数据类型’的数据进行存储
                ・将数组中的数据存储到‘堆区’
                ・构造函数中可以传入数组的容量
                ・提供对应的拷贝函数以及赋值运算符重载，‘解决浅拷贝’的问题
                ・提供尾插法和尾删法对数组中的数据进行增加和删除
                ・可以通过下标的方式访问数组中的元素（[]的重载）
                ・可以获取数组中当前元素个数和数组的容量

                ・已上传至GITHUB
    2.STL初始
        2.1STL的诞生
            ・C++的面向对象和泛型编程的思想，目的就是复用性的提升
            ・大多数情况下，数据结构和算法都未能有一套标准，导致被迫提高重复工作
            ・为了建立数据结构和算法的一套标准，诞生了STL
        2.2STL
            ・STL(Standard Template Libary 标准模板库)
            ・STL广义上分为：容器(container) 算法(algorithm) 迭代器(iterator)
            ・‘容器’和‘算法’之间通过‘迭代器’进行无缝连接
            ・STL几乎所有代码都采用模板类或着模板函数
        2.3STL六大组件
            容器 算法 迭代器 仿函数 适配器（配接器） 空间配置器
            1.容器：各种数据结构，用来存放数据
            2.算法：各种常用算法
            3.迭代器：为了扮演容器与算法之间的胶合剂
            4.仿函数：行为类似函数，可作为算法的某种策略
            5.适配器：一种用来修饰容器或者仿函数或迭代器接口的东西
            6.空间配置器：负责空间的配置与管理
        2.4STL中容器、算法、迭代器  
            容器：将运用最广泛的一些数据结构实现出来
                容器可以分为：
                    序列是容器：强调值得排序，容器中得每个元素都有固定的位置
                    关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系
            算法：有限的步骤，解决逻辑或数学上的问题(Algorithm)
                算法可以分为：
                    质变算法：指运算过程中会更改区间内元素的内容，例如拷贝、替换、删除
                    非质变算法：指运算过程中不会更改区间内元素的内容，例如查看、计算、遍历
            迭代器：容器和算法的桥梁
                算法需要通过迭代器访问容器里的数据...
                每个容器都有自己专属的迭代器
                迭代器使用非常类似于指针...
                迭代器的种类：
                    输入          对数据的只读访问
                    输出          对数据的只写访问
                    前向          读写，并能向前推进迭代器
                    双向          读写，并能向前和向后
                    随机访问      读写，可以跳跃式访问任何数据

        2.5容器算法迭代器初始
            2.5.1vector存放内置数据类型
                容器：vector
                算法：for_each
                迭代器：vector<int>::iterator
                void myPrint(int val)
                {
                    cout<<val<<endl;
                }
                void test()
                {
                    vector<int>v;

                //像容器中插入数据，尾插
                    v.push_back(10);
                    v.push_back(20);
                    v.push_back(30);

                    //第一中遍历方式

                    //begin()指向容器中第一个元素
                    vector<int>::iterator itBegin=v.begin(); 
                    //end()指向容器中最后一个元素的下一个位置 
                    vector<int>::iterator itEnd=v.end();

                    while(itBegin!=itEnd)
                    {
                        //解引用
                        cout<<*itBegin<<endl;
                        itBegin++;
                    }

                //第二种遍历的方式
                for(vector<int>::iterator it=v.begin();it!=v.end();it++)
                {
                    cout<<*it<<endl;
                }

                //第三种遍历  利用STL提供遍历算法
                for_each(v.begin(),v.end(),myPrint);
                }
            2.5.2vector存放自定义数据类型
                class Person
                {
                public:
                    Person(string name,int age)
                {
                    this->m_name=name;
                    this->m_age=age;
                }
                
                    int m_age;
                    string m_name;
                };
                
                void test()
                {
                    Person p1("aaa",10);
                    Person p2("bbb",20);
                
                    vector<Person> v;
                    v.push_back(p1);
                    v.push_back(p2);
                
                    for(vector<Person>::iterator it=v.begin();it!=v.end();it++)
                    {
                        cout<<it->m_age<<" "<<it->m_name<<endl;
                    }
                }
            2.5.3vector容器嵌套容器
                void test()
                {
                    //大
                    vector<vector<int>>v;
                    //小
                    vector<int>v1;
                    vector<int>v2;
                
                    //向小容器中添加数据
                    for(int i=0;i<4;i++)
                    {
                        v1.push_back(i+1);
                        v2.push_back(i+2);
                    }
                
                    //将小容器插入到大容器中
                    v.push_back(v1);
                    v.push_back(v2);
                
                    for(vector<vector<int>>::iterator it=v.begin();it!=v.end();it++)
                    {
                        for(vector<int>::iterator vit=it->begin();vit!=it->end();vit++)
                            cout<<*vit<<" "<<endl;
                    }
                }
    3.STL常用容器
        3.1string容器
            3.1.1string基本概念
                本质：类
                string 和char* 区别：
                    1.char*是一个指针
                    2.string是一个类，类内部封装了  char* ，管理这个字符串
                    特点：
                        string类内部封装了很多成员方法
                        例如：查找find，拷贝copy，删除delete
                        string管理char* 所分配的内存，不用担心复制越界和取值越界，由类内部负责
            3.1.2string构造函数
                string();
                string(const cha* s);
                string(const string& str);
                string(int n,char c);//输出n个c
            3.1.3string的赋值操作
                功能描述：给string 字符串进行赋值
                1.= 2.assign()
            3.1.4string字符串拼接
                功能描述：实现在字符串末尾拼接字符串
                1.+= 2.append
            3.1.5string查找和替换
                功能描述：1.查找：查找指定字符串是否存在 2.替换：在指定的位置替换字符串
                1.find rfind 2.replace
            3.1.6string字符串比较
                功能描述：字符串之间的比较
                比较方式：字符串比较是按字符的ASCII码逐个进行对比  1.相等= 0 2.大于> 1 3.小于< -1
                1.compare
            3.1.7string字符存取
                功能描述：对指定位置访问元素，可以修改元素  
                1.[](符号重载) 2.at(访问单个字符)
            3.1.8string插入和删除
                功能描述：对字符串进行插入和删除
                1.insert 2.erase    
            3.1.9string子串
                功能描述：从字符串中截取想要的字串
                1.substr
                总结：灵活运用可以在开发中获取有效信息
        3.2vector容器
            3.2.1基本概念
                功能：vector数据结构和数组非常相似，也称为单端数据
                vector和普通数组的区别：
                    数组是静态的，而vector是可以动态扩展的
                动态扩展：
                    ・是寻找更大的内存空间，拷贝原内容后添加新内容
                    ・vector容器的迭代器是支持随机访问的迭代器
            3.2.2vector构造函数
                功能描述：创建vector容器
                函数原型：
                    vertor<T> v;                   //采用模板实现类实现，默认构造函数
                    vertor<v.begin(),v.end()>;     //将v[begin(),end()]区间中的元素拷贝给本省
                    vector(n,elem);                //构造函数将n个elem拷贝给本身
                    vector(const vector &vec);     //拷贝构造函数
            3.2.3vector赋值操作
                功能描述：给vector容器赋值
                1.= 2.assign()
            3.2.4vector容量和大小
                功能描述：获取vector容器大小
                1.empty() 2.capacity() 3.size() 4.resize(int num) 5.resize(int num,elem)
            3.2.5vector插入和删除
                1.push_back() 2.pop_back() 3.insert(v1.begin(),10) 4.erase(v1,begin(),2) 5.clear()
            3.2.6vector数据存取
                1.at(int index) 2.operator[] 3.front()返回第一个元素 4.back()返回容器中最后一个元素
            3.2.7vector互换容器
                功能实现：实现两个容器内元素互换
                1.swap(vec);
                ・巧用swap可以收缩内存空间
                vector<int>(v).swap(v);
                //（x）vector<int>(v)->匿名对象，用后自动删除
                //v和匿名对象x交换，实现收缩内存
            3.2.8vector预留空间
                功能描述：减少vector在‘动态扩展’容量时的扩展次数
                1.reserve(int len)//容器预留len个元素长度，预留位置不初始化，所以不可以访问
                总结：如果数据量较大，可以一开始便使用reserve
        3.3deque容器
            功能：双端数组，可以对头端进行插入删除操作
            与vector区别：
                ・vector为单端，数据量越大效率越低
                ・deque相对而言，对头部的插入删除速度会比vector快
                ・vector访问元素时的速度会比deque快，这和两者的内部实现有关
            内部工作原理：
                deque内部有个‘中控器’，维护每‘段’‘缓冲区’的内容，缓冲区存放真实数据
                中控器维护的是缓冲区的地址，使得使用deque时像一片连续的内存地址
                
                Deque容器的迭代器也是支持随机访问的
            3.3.2deque构造函数
                1.和vector一样
            3.3.3赋值操作
                1.和vector一样
            3.3.4大小操作
                1.和vector大致一样，但没有获取容量机制
            3.3.5插入和删除
                1.push_front() //头插 2.pop_front()
                3.其余和vector一样
            3.3.6数据存取
                1.front()//获取第一个元素 2.back()获取最后一个元素
                3.其余与vector一样
            3.3.7排序操作
                利用算法对容器排序
                1.sort(iterator begin(),iterator end());
                总结：对于支持随机访问的迭代器容器，都可以使用sort()
        3.4案例练习
                class Person
                {
                public:
                    Person(string name,int score)
                {
                    this->m_name=name;
                    this->m_score=score;
                }
                    int m_score;
                    string m_name;
                };
                
                void CreatePerson(vector<Person>&v)
                {
                    string nameSeed="ABCDE";
                    for(int i=0;i<5;i++)
                    {
                        string name="选手";
                        name+=nameSeed[i];
                        int score=0;
                        Person p(name,score);
                        v.push_back(p);
                    }
                }
                
                void SetScore(vector<Person>&v)
                {
                    srand((unsigned int)time(NULL));
                    for(vector<Person>::iterator it=v.begin();it!=v.end();it++)
                    {
                        deque<int>J;
                        for(int i=0;i<10;i++)
                        {      
                            int num=rand()%41+60;//随机60~100分
                            J.push_back(num);
                        }
                        sort(J.begin(),J.end());
                        J.pop_front();
                        J.pop_back();
                        int num=0;   //此处为总分
                        for(deque<int>::iterator dit=J.begin();dit!=J.end();dit++)
                        {
                            num+=*dit;   
                        }
                        int avg=0;
                        avg=num/J.size();
                        it->m_score=avg;
                    }
                }
                
                void show(vector<Person>v)
                {
                    for(vector<Person>::iterator it=v.begin();it!=v.end();it++)
                    {
                        cout<<"选手姓名："<<it->m_name<<" "<<"选手分数："<<it->m_score<<endl;
                    }
                }
                void test()
                {
                    //v1中创建5名选手
                    vector<Person>v1;
                
                    CreatePerson(v1);
                
                    SetScore(v1);
                
                    show(v1);
                
                }
        3.5stack容器
            3.5.1基本概念
                本质：栈
                注意事项：1.先进后出 2.不允许遍历行为
            3.5.2常用接口
                1.stack<T>stk 2.stack(const stack &s)
                3.stack operator=(const stack& stk)
                4.push()  5.pop() 6.top()//返回栈顶元素
                7.empty() //判断是否为空 8.size() //返回栈的大小
        3.6queue容器
            3.6.1基本概念    
                本质：队列
                注意事项：1.先进先出 2.不允许有遍历行为，只能访问队头(front)和队尾(back)
            3.6.2常用接口
                除了top()其余和stack一样
                1.front()//返回队头 2.back()//返回队尾
        3.7list容器
            3.7.1基本概念
                本质：链表
                注意事项：
                    1.STL中的链表是一个‘双向循环’链表
                    2.list中的迭代器只支持前移和后移，属于双向迭代器
            3.7.2构造函数
                1.list<T>lst 2list(beg(),end()) 
                3.list(n,elem) 4.list(const list &lst)
            3.7.3赋值和交换
                1.operator= 2.assign(n,elem) 3.assign(beg,end) 
                3.swap(lst)
            3.7.4大小操作
                除了容量Capacity()外，其余与vector一致
            3.7.5插入和删除
                1.push_back() 2.push_front() 3.pop_back() 4.pop_back()
                5.insert(pos,elem) 6.insert(pos,n,elem) 7.insert(pos,beg,end)
                8.clear() 9.erase(beg,end) 10.remove(elem)//删除容器中所有与elem所匹配的数据
                /*pos ->使用迭代器
                    list<int>::iterator it=L.begin();
                    insert(++it,elem);*/
            3.7.6数据存取
                1.front() //返回第一个元素2.back()//返回最后一个元素 
                注意事项：1.无[]重载 2.无at()，迭代器不支持随机访问
            3.7.7反转和排序  
                1.reverse() 
                //所有不支持随机访问的迭代器的容器‘不支持’算法
                //不支持随机访问的迭代器的容器内部会提供一些成员函数的算法
                2.sort() //默认升序，降序‘提供布尔类型’的回调函数，返回 v1>v2
                //在排序自定义数据类型时需要提供‘一定规则（回调函数）’
        3.8set/multiset容器
            3.8.1基本概念
                本质：属于关联式容器，底层为二叉树
                特点：所有元素都会在插入时自动被排序
                区别：set不允许有重复的元素而multiset允许
            3.8.2set构造和赋值
                1.set<T>st 2.set(const set& st)
                3.operator=
            3.8.3set大小和交换
                1.size() 2.empty() 3.swap(st)
            3.8.4set插入和删除
                1.insert(elem) 2.clear() 3.erase(pos/beg,end/elem)
            3.8.5set查找和统计
                1.find(key)//存在返回该键的迭代器，不存在返回st.end() 2.count(key)//计数
            3.8.6set和multiset区别
                1.set不可以插入重复数据
                2.set插入数据的同时会返回插入结果，表示插入是否成功（返回迭代器和布尔）
                3.multiset插入数据时不检测数据，因此可以重复插入
            3.8.7pair对组创建
                功能描述：成对出现的数据，利用队组可以返回两个数据
                语法：（不需要包含头文件）
                    1.pair<type,type>p(val1,val2);
                    2.pair<type,type>p=make_pair(val1,val2);

                    pair<string,int>p("Tom",20);
                    cout<<"姓名："<<p.first<<"年龄："<<p.second<<endl;
                    pair<string,int>p1=make_pair("jery",30);
                    cout<<"姓名："<<p1.first<<"年龄："<<p1.second<<endl;
            3.8.8set排序
                利用仿函数可以改变排序规则
                class Person
                {
                public:

                    Person(string name,int age)
                    {
                        this->m_age=age;
                        this->m_name=name;
                    }
                    int m_age;
                    string m_name;
                };

                //仿函数本质是个数据类型
                class Mycompare
                {
                public:
                    bool operator()(int v1,int v2)
                    {
                        return v1>v2;
                    }
                };

                class Diy_Mycompare
                {
                public:
                    bool operator()(const Person& p1,const Person &p2)
                    {
                        return p1.m_age>p2.m_age;
                    }
                };
                void test()
                {
                    //set存放内置数据类型
                    set<int>s1;

                    s1.insert(10);
                    s1.insert(30);
                    s1.insert(50);
                    s1.insert(20);

                    for(set<int>::iterator it=s1.begin();it!=s1.end();it++)
                    {
                        cout<<*it<<" ";
                    }
                    cout<<endl;

                    set<int,Mycompare>s2;

                    s2.insert(10);
                    s2.insert(30);
                    s2.insert(50);
                    s2.insert(20);

                    for(set<int,Mycompare>::iterator it=s2.begin();it!=s2.end();it++)
                    {
                        cout<<*it<<" ";
                    }
                    cout<<endl;

                    //set存放自定义数据类型

                    Person p1("刘备",25);
                    Person p2("张飞",26);
                    Person p3("关羽",27);

                    set<Person,Diy_Mycompare>s3;

                    s3.insert(p1);
                    s3.insert(p2);
                    s3.insert(p3);
                    
                    for(set<Person,Diy_Mycompare>::iterator it=s3.begin();it!=s3.end();it++)
                    {
                        cout<<"姓名："<<it->m_name<<" "<<"年龄："<<it->m_age<<endl;
                    }
                    cout<<endl;
                }
        3.9map/multimap容器
            3.9.1基本概念
                本质：
                    map/multimap属于关联式容器，底层用二叉树实现
                特点：
                    1.map中‘所有’元素都是‘pair’
                    2.键&值(python中的diractor)
                    3.‘所有元素’都会根据元素的键值自动排序
                优点：
                    1.可以根据key值‘快速’找到value值
                    2.map‘不允许’容器中有重复的key值
                    3.multimap‘允许’容器中有重复的key值
            3.9.2map构造和赋值
                1.与set/multiset一致，但数据类型中必须是‘成对’的 map<int,int>m;
            3.9.3大小和交换
                1.与set/multiset一致
            3.9.4插入和删除
                1.1 insert(pair<int,int>(elem,elem)) 
                1.2 insert(make_pair(elem,elem)) 
                1.3 insert(map(<int,int>::valuetype(key,value))) 
                1.4 m[4] //不建议，主要用key来访问value,例如用键4 （m[4]）访问值 
                2.其余与mat/multiset一致，删除时按照key来删除，
            3.9.5查找和统计
                1.‘按照key’查找与统计，其余与set一致
            3.9.6排序
                利用仿函数可以改变排序规则
                class Person
                {
                public:

                    Person(string name,int age)
                    {
                        this->m_age=age;
                        this->m_name=name;
                    }
                    int m_age;
                    string m_name;
                };

                //仿函数本质是个数据类型
                class Mycompare
                {
                public:
                    bool operator()(int v1,int v2)
                    {
                        return v1>v2;
                    }
                };

                void test()
                {
                    //map存放内置数据类型
                    map<int,int,Mycompare>p1;
                    p1.insert(make_pair(1,10));
                    p1.insert(make_pair(2,30));

                    //map存放自定义数据类型
                    map<int,Person,Mycompare>p2;
                    p2.insert(make_pair(1,Person("张三",20)));
                    p2.insert(make_pair(2,Person("李四",30)));

                    for(map<int,Person>::iterator it=p2.begin();it!=p2.end();it++)
                    {
                        cout<<"键："<<it->first<<"值->姓名："
                        <<it->second.m_name<<"值->年龄："<<it->second.m_age<<endl;
                    }
                }

                


